{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Admin\\\\Downloads\\\\Task Management System\\\\frontend\\\\src\\\\context\\\\TaskContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useMemo } from 'react';\nimport { toast } from 'react-toastify';\nimport taskService from '../services/taskService';\nimport useTaskOptimizations from '../hooks/useTaskOptimizations';\nimport { useAuth } from './AuthContext';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst TaskContext = /*#__PURE__*/createContext(null);\nexport const TaskProvider = ({\n  children\n}) => {\n  _s();\n  const [tasks, setTasks] = useState([]);\n  const [currentTask, setCurrentTask] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Use task optimizations hook\n  const {\n    debounce,\n    cacheTasks,\n    getCachedTasks\n  } = useTaskOptimizations();\n\n  // Get current user from auth context\n  const {\n    user\n  } = useAuth();\n\n  // Fetch all tasks or filter by project or user\n  const fetchTasks = useCallback(async (filters = {}) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTasks(filters);\n      setTasks(data);\n      return data;\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n      setError(error.message || 'Failed to fetch tasks');\n      toast.error('Failed to fetch tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch tasks by project ID with caching\n  const fetchTasksByProject = useCallback(async projectId => {\n    try {\n      // First check cache\n      const cachedData = getCachedTasks(projectId);\n      if (cachedData) {\n        setTasks(cachedData);\n\n        // Refresh in background after returning cached data\n        taskService.getTasksByProject(projectId).then(freshData => {\n          setTasks(freshData);\n          cacheTasks(projectId, freshData);\n        }).catch(err => console.error('Background refresh failed:', err));\n        return cachedData;\n      }\n\n      // If no cache hit, fetch normally\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTasksByProject(projectId);\n      setTasks(data);\n\n      // Store in cache for future use\n      cacheTasks(projectId, data);\n      return data;\n    } catch (error) {\n      console.error(`Error fetching tasks for project ${projectId}:`, error);\n      setError(error.message || 'Failed to fetch project tasks');\n      toast.error('Failed to fetch project tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, [getCachedTasks, cacheTasks]);\n\n  // Fetch tasks by user ID (defaults to current user)\n  const fetchUserTasks = useCallback(async userId => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // If no userId is provided and user exists, use current user's ID\n      const targetUserId = userId || user && user._id;\n      if (!targetUserId) {\n        console.error('No user ID provided and no current user');\n        setError('User not found');\n        toast.error('Failed to fetch user tasks: User not found');\n        return [];\n      }\n      const data = await taskService.getTasksByUser(targetUserId);\n      setTasks(data);\n      return data;\n    } catch (error) {\n      console.error(`Error fetching tasks for user:`, error);\n      setError(error.message || 'Failed to fetch user tasks');\n      toast.error('Failed to fetch user tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, [user]);\n\n  // Fetch a single task by ID\n  const fetchTask = useCallback(async taskId => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTask(taskId);\n      setCurrentTask(data);\n      return data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error(`Error fetching task ${taskId}:`, error);\n      setError(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to fetch task');\n      toast.error('Failed to fetch task details');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Create task with debouncing to prevent duplicate submissions\n  const createTask = useCallback(taskData => {\n    return debounce(async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const newTask = await taskService.createTask(taskData);\n        setTasks(prevTasks => [...prevTasks, newTask]);\n        toast.success('Task created successfully');\n        return newTask;\n      } catch (error) {\n        console.error('Error creating task:', error);\n        setError(error.message || 'Failed to create task');\n        toast.error('Failed to create task');\n        return null;\n      } finally {\n        setLoading(false);\n      }\n    }, 'createTask', 500)();\n  }, [debounce]);\n\n  // Update a task\n  const updateTask = useCallback(async (taskId, taskData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.updateTask(taskId, taskData);\n\n      // Update tasks list\n      setTasks(prevTasks => prevTasks.map(task => task._id === taskId ? data : task));\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Task updated successfully!');\n      return data;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      console.error(`Error updating task ${taskId}:`, error);\n      setError(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to update task');\n      toast.error('Failed to update task');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Delete a task\n  const deleteTask = useCallback(async taskId => {\n    try {\n      setLoading(true);\n      setError(null);\n      await taskService.deleteTask(taskId);\n\n      // Remove from tasks list\n      setTasks(prevTasks => prevTasks.filter(task => task._id !== taskId));\n\n      // Clear current task if it's the one being deleted\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(null);\n      }\n      toast.success('Task deleted successfully!');\n      return true;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      console.error(`Error deleting task ${taskId}:`, error);\n      setError(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to delete task');\n      toast.error('Failed to delete task');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Add a comment to a task\n  const addComment = useCallback(async (taskId, comment) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.addComment(taskId, comment);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Comment added successfully!');\n      return data;\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      console.error(`Error adding comment to task ${taskId}:`, error);\n      setError(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'Failed to add comment');\n      toast.error('Failed to add comment');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Upload attachment to a task\n  const uploadAttachment = useCallback(async (taskId, file) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.uploadAttachment(taskId, file);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('File uploaded successfully!');\n      return data;\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      console.error(`Error uploading file to task ${taskId}:`, error);\n      setError(((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || 'Failed to upload file');\n      toast.error('Failed to upload file');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Delete attachment from a task\n  const deleteAttachment = useCallback(async (taskId, attachmentId) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.deleteAttachment(taskId, attachmentId);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Attachment deleted successfully!');\n      return data;\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      console.error(`Error deleting attachment from task ${taskId}:`, error);\n      setError(((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.message) || 'Failed to delete attachment');\n      toast.error('Failed to delete attachment');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Memoize context value\n  const contextValue = useMemo(() => ({\n    tasks,\n    currentTask,\n    loading,\n    error,\n    fetchTasks,\n    fetchTasksByProject,\n    fetchUserTasks,\n    fetchTask,\n    createTask,\n    updateTask,\n    deleteTask,\n    addComment,\n    uploadAttachment,\n    deleteAttachment\n  }), [tasks, currentTask, loading, error, fetchTasks, fetchTasksByProject, fetchUserTasks, fetchTask, createTask, updateTask, deleteTask, addComment, uploadAttachment, deleteAttachment]);\n  return /*#__PURE__*/_jsxDEV(TaskContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 310,\n    columnNumber: 9\n  }, this);\n};\n\n// Custom hook to use the task context\n_s(TaskProvider, \"oIbvT93UtIHobOz2oEgxlxuLKFo=\", false, function () {\n  return [useTaskOptimizations, useAuth];\n});\n_c = TaskProvider;\nexport const useTask = () => {\n  _s2();\n  const context = useContext(TaskContext);\n  if (!context) {\n    throw new Error('useTask must be used within a TaskProvider');\n  }\n  return context;\n};\n_s2(useTask, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TaskProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useMemo","toast","taskService","useTaskOptimizations","useAuth","jsxDEV","_jsxDEV","TaskContext","TaskProvider","children","_s","tasks","setTasks","currentTask","setCurrentTask","loading","setLoading","error","setError","debounce","cacheTasks","getCachedTasks","user","fetchTasks","filters","data","getTasks","console","message","fetchTasksByProject","projectId","cachedData","getTasksByProject","then","freshData","catch","err","fetchUserTasks","userId","targetUserId","_id","getTasksByUser","fetchTask","taskId","getTask","_error$response","_error$response$data","response","createTask","taskData","newTask","prevTasks","success","updateTask","map","task","_error$response2","_error$response2$data","deleteTask","filter","_error$response3","_error$response3$data","addComment","comment","_error$response4","_error$response4$data","uploadAttachment","file","_error$response5","_error$response5$data","deleteAttachment","attachmentId","_error$response6","_error$response6$data","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTask","_s2","context","Error","$RefreshReg$"],"sources":["C:/Users/Admin/Downloads/Task Management System/frontend/src/context/TaskContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useMemo } from 'react';\r\nimport { toast } from 'react-toastify';\r\nimport taskService from '../services/taskService';\r\nimport useTaskOptimizations from '../hooks/useTaskOptimizations';\r\nimport { useAuth } from './AuthContext';\r\n\r\n// Create context\r\nconst TaskContext = createContext(null);\r\n\r\nexport const TaskProvider = ({ children }) => {\r\n    const [tasks, setTasks] = useState([]);\r\n    const [currentTask, setCurrentTask] = useState(null);\r\n    const [loading, setLoading] = useState(false);\r\n    const [error, setError] = useState(null);\r\n\r\n    // Use task optimizations hook\r\n    const { debounce, cacheTasks, getCachedTasks } = useTaskOptimizations();\r\n\r\n    // Get current user from auth context\r\n    const { user } = useAuth();\r\n\r\n    // Fetch all tasks or filter by project or user\r\n    const fetchTasks = useCallback(async (filters = {}) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.getTasks(filters);\r\n            setTasks(data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error('Error fetching tasks:', error);\r\n            setError(error.message || 'Failed to fetch tasks');\r\n            toast.error('Failed to fetch tasks');\r\n            return [];\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, []);\r\n\r\n    // Fetch tasks by project ID with caching\r\n    const fetchTasksByProject = useCallback(async (projectId) => {\r\n        try {\r\n            // First check cache\r\n            const cachedData = getCachedTasks(projectId);\r\n            if (cachedData) {\r\n                setTasks(cachedData);\r\n\r\n                // Refresh in background after returning cached data\r\n                taskService.getTasksByProject(projectId).then(freshData => {\r\n                    setTasks(freshData);\r\n                    cacheTasks(projectId, freshData);\r\n                }).catch(err => console.error('Background refresh failed:', err));\r\n\r\n                return cachedData;\r\n            }\r\n\r\n            // If no cache hit, fetch normally\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.getTasksByProject(projectId);\r\n            setTasks(data);\r\n\r\n            // Store in cache for future use\r\n            cacheTasks(projectId, data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error fetching tasks for project ${projectId}:`, error);\r\n            setError(error.message || 'Failed to fetch project tasks');\r\n            toast.error('Failed to fetch project tasks');\r\n            return [];\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [getCachedTasks, cacheTasks]);\r\n\r\n    // Fetch tasks by user ID (defaults to current user)\r\n    const fetchUserTasks = useCallback(async (userId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            \r\n            // If no userId is provided and user exists, use current user's ID\r\n            const targetUserId = userId || (user && user._id);\r\n            \r\n            if (!targetUserId) {\r\n                console.error('No user ID provided and no current user');\r\n                setError('User not found');\r\n                toast.error('Failed to fetch user tasks: User not found');\r\n                return [];\r\n            }\r\n            \r\n            const data = await taskService.getTasksByUser(targetUserId);\r\n            setTasks(data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error fetching tasks for user:`, error);\r\n            setError(error.message || 'Failed to fetch user tasks');\r\n            toast.error('Failed to fetch user tasks');\r\n            return [];\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [user]);\r\n\r\n    // Fetch a single task by ID\r\n    const fetchTask = useCallback(async (taskId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.getTask(taskId);\r\n            setCurrentTask(data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error fetching task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to fetch task');\r\n            toast.error('Failed to fetch task details');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, []);\r\n\r\n    // Create task with debouncing to prevent duplicate submissions\r\n    const createTask = useCallback((taskData) => {\r\n        return debounce(async () => {\r\n            try {\r\n                setLoading(true);\r\n                setError(null);\r\n                const newTask = await taskService.createTask(taskData);\r\n                setTasks(prevTasks => [...prevTasks, newTask]);\r\n                toast.success('Task created successfully');\r\n                return newTask;\r\n            } catch (error) {\r\n                console.error('Error creating task:', error);\r\n                setError(error.message || 'Failed to create task');\r\n                toast.error('Failed to create task');\r\n                return null;\r\n            } finally {\r\n                setLoading(false);\r\n            }\r\n        }, 'createTask', 500)();\r\n    }, [debounce]);\r\n\r\n    // Update a task\r\n    const updateTask = useCallback(async (taskId, taskData) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.updateTask(taskId, taskData);\r\n\r\n            // Update tasks list\r\n            setTasks(prevTasks =>\r\n                prevTasks.map(task =>\r\n                    task._id === taskId ? data : task\r\n                )\r\n            );\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('Task updated successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error updating task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to update task');\r\n            toast.error('Failed to update task');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Delete a task\r\n    const deleteTask = useCallback(async (taskId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            await taskService.deleteTask(taskId);\r\n\r\n            // Remove from tasks list\r\n            setTasks(prevTasks =>\r\n                prevTasks.filter(task => task._id !== taskId)\r\n            );\r\n\r\n            // Clear current task if it's the one being deleted\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(null);\r\n            }\r\n\r\n            toast.success('Task deleted successfully!');\r\n            return true;\r\n        } catch (error) {\r\n            console.error(`Error deleting task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to delete task');\r\n            toast.error('Failed to delete task');\r\n            return false;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Add a comment to a task\r\n    const addComment = useCallback(async (taskId, comment) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.addComment(taskId, comment);\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('Comment added successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error adding comment to task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to add comment');\r\n            toast.error('Failed to add comment');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Upload attachment to a task\r\n    const uploadAttachment = useCallback(async (taskId, file) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.uploadAttachment(taskId, file);\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('File uploaded successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error uploading file to task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to upload file');\r\n            toast.error('Failed to upload file');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Delete attachment from a task\r\n    const deleteAttachment = useCallback(async (taskId, attachmentId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.deleteAttachment(taskId, attachmentId);\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('Attachment deleted successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error deleting attachment from task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to delete attachment');\r\n            toast.error('Failed to delete attachment');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Memoize context value\r\n    const contextValue = useMemo(() => ({\r\n        tasks,\r\n        currentTask,\r\n        loading,\r\n        error,\r\n        fetchTasks,\r\n        fetchTasksByProject,\r\n        fetchUserTasks,\r\n        fetchTask,\r\n        createTask,\r\n        updateTask,\r\n        deleteTask,\r\n        addComment,\r\n        uploadAttachment,\r\n        deleteAttachment\r\n    }), [\r\n        tasks,\r\n        currentTask,\r\n        loading,\r\n        error,\r\n        fetchTasks,\r\n        fetchTasksByProject,\r\n        fetchUserTasks,\r\n        fetchTask,\r\n        createTask,\r\n        updateTask,\r\n        deleteTask,\r\n        addComment,\r\n        uploadAttachment,\r\n        deleteAttachment\r\n    ]);\r\n\r\n    return (\r\n        <TaskContext.Provider value={contextValue}>\r\n            {children}\r\n        </TaskContext.Provider>\r\n    );\r\n};\r\n\r\n// Custom hook to use the task context\r\nexport const useTask = () => {\r\n    const context = useContext(TaskContext);\r\n    if (!context) {\r\n        throw new Error('useTask must be used within a TaskProvider');\r\n    }\r\n    return context;\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}