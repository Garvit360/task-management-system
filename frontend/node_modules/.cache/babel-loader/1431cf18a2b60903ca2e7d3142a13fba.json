{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Admin\\\\Downloads\\\\Task Management System\\\\frontend\\\\src\\\\context\\\\TaskContext.jsx\";\nimport React, { createContext, useContext, useState, useCallback, useMemo } from 'react';\nimport { toast } from 'react-toastify';\nimport taskService from '../services/taskService';\nimport useTaskOptimizations from '../hooks/useTaskOptimizations';\nimport { useAuth } from './AuthContext';\n\n// Create context\nconst TaskContext = createContext(null);\nexport const TaskProvider = ({\n  children\n}) => {\n  const [tasks, setTasks] = useState([]);\n  const [currentTask, setCurrentTask] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Use task optimizations hook\n  const {\n    debounce,\n    cacheTasks,\n    getCachedTasks\n  } = useTaskOptimizations();\n\n  // Get current user from auth context\n  const {\n    user\n  } = useAuth();\n\n  // Fetch all tasks or filter by project or user\n  const fetchTasks = useCallback(async (filters = {}) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTasks(filters);\n      setTasks(data);\n      return data;\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n      setError(error.message || 'Failed to fetch tasks');\n      toast.error('Failed to fetch tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch tasks by project ID with caching\n  const fetchTasksByProject = useCallback(async projectId => {\n    try {\n      // First check cache\n      const cachedData = getCachedTasks(projectId);\n      if (cachedData) {\n        setTasks(cachedData);\n\n        // Refresh in background after returning cached data\n        taskService.getTasksByProject(projectId).then(freshData => {\n          setTasks(freshData);\n          cacheTasks(projectId, freshData);\n        }).catch(err => console.error('Background refresh failed:', err));\n        return cachedData;\n      }\n\n      // If no cache hit, fetch normally\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTasksByProject(projectId);\n      setTasks(data);\n\n      // Store in cache for future use\n      cacheTasks(projectId, data);\n      return data;\n    } catch (error) {\n      console.error(`Error fetching tasks for project ${projectId}:`, error);\n      setError(error.message || 'Failed to fetch project tasks');\n      toast.error('Failed to fetch project tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, [getCachedTasks, cacheTasks]);\n\n  // Fetch tasks for current user or specified user\n  const fetchUserTasks = useCallback(async userId => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Use 'me' to get current user's tasks\n      const data = await taskService.getTasksByUser(userId || 'me');\n      setTasks(data);\n      return data;\n    } catch (error) {\n      console.error(`Error fetching user tasks:`, error);\n      setError(error.message || 'Failed to fetch user tasks');\n      toast.error('Failed to fetch user tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch a single task by ID\n  const fetchTask = useCallback(async taskId => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTask(taskId);\n      setCurrentTask(data);\n      return data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error(`Error fetching task ${taskId}:`, error);\n      setError(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to fetch task');\n      toast.error('Failed to fetch task details');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Create task with debouncing to prevent duplicate submissions\n  const createTask = useCallback(taskData => {\n    return debounce(async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const newTask = await taskService.createTask(taskData);\n        setTasks(prevTasks => [...prevTasks, newTask]);\n        toast.success('Task created successfully');\n        return newTask;\n      } catch (error) {\n        console.error('Error creating task:', error);\n        setError(error.message || 'Failed to create task');\n        toast.error('Failed to create task');\n        return null;\n      } finally {\n        setLoading(false);\n      }\n    }, 'createTask', 500)();\n  }, [debounce]);\n\n  // Update a task\n  const updateTask = useCallback(async (taskId, taskData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.updateTask(taskId, taskData);\n\n      // Update tasks list\n      setTasks(prevTasks => prevTasks.map(task => task._id === taskId ? data : task));\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Task updated successfully!');\n      return data;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      console.error(`Error updating task ${taskId}:`, error);\n      setError(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to update task');\n      toast.error('Failed to update task');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Delete a task\n  const deleteTask = useCallback(async taskId => {\n    try {\n      setLoading(true);\n      setError(null);\n      await taskService.deleteTask(taskId);\n\n      // Remove from tasks list\n      setTasks(prevTasks => prevTasks.filter(task => task._id !== taskId));\n\n      // Clear current task if it's the one being deleted\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(null);\n      }\n      toast.success('Task deleted successfully!');\n      return true;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      console.error(`Error deleting task ${taskId}:`, error);\n      setError(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to delete task');\n      toast.error('Failed to delete task');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Add a comment to a task\n  const addComment = useCallback(async (taskId, comment) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.addComment(taskId, comment);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Comment added successfully!');\n      return data;\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      console.error(`Error adding comment to task ${taskId}:`, error);\n      setError(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'Failed to add comment');\n      toast.error('Failed to add comment');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Upload attachment to a task\n  const uploadAttachment = useCallback(async (taskId, file) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.uploadAttachment(taskId, file);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('File uploaded successfully!');\n      return data;\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      console.error(`Error uploading file to task ${taskId}:`, error);\n      setError(((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || 'Failed to upload file');\n      toast.error('Failed to upload file');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Delete attachment from a task\n  const deleteAttachment = useCallback(async (taskId, attachmentId) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.deleteAttachment(taskId, attachmentId);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Attachment deleted successfully!');\n      return data;\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      console.error(`Error deleting attachment from task ${taskId}:`, error);\n      setError(((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.message) || 'Failed to delete attachment');\n      toast.error('Failed to delete attachment');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Memoize context value\n  const contextValue = useMemo(() => ({\n    tasks,\n    currentTask,\n    loading,\n    error,\n    fetchTasks,\n    fetchTasksByProject,\n    fetchUserTasks,\n    fetchTask,\n    createTask,\n    updateTask,\n    deleteTask,\n    addComment,\n    uploadAttachment,\n    deleteAttachment\n  }), [tasks, currentTask, loading, error, fetchTasks, fetchTasksByProject, fetchUserTasks, fetchTask, createTask, updateTask, deleteTask, addComment, uploadAttachment, deleteAttachment]);\n  return /*#__PURE__*/React.createElement(TaskContext.Provider, {\n    value: contextValue,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 301,\n      columnNumber: 9\n    }\n  }, children);\n};\n\n// Custom hook to use the task context\nexport const useTask = () => {\n  const context = useContext(TaskContext);\n  if (!context) {\n    throw new Error('useTask must be used within a TaskProvider');\n  }\n  return context;\n};","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useMemo","toast","taskService","useTaskOptimizations","useAuth","TaskContext","TaskProvider","children","tasks","setTasks","currentTask","setCurrentTask","loading","setLoading","error","setError","debounce","cacheTasks","getCachedTasks","user","fetchTasks","filters","data","getTasks","console","message","fetchTasksByProject","projectId","cachedData","getTasksByProject","then","freshData","catch","err","fetchUserTasks","userId","getTasksByUser","fetchTask","taskId","getTask","_error$response","_error$response$data","response","createTask","taskData","newTask","prevTasks","success","updateTask","map","task","_id","_error$response2","_error$response2$data","deleteTask","filter","_error$response3","_error$response3$data","addComment","comment","_error$response4","_error$response4$data","uploadAttachment","file","_error$response5","_error$response5$data","deleteAttachment","attachmentId","_error$response6","_error$response6$data","contextValue","createElement","Provider","value","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","useTask","context","Error"],"sources":["C:/Users/Admin/Downloads/Task Management System/frontend/src/context/TaskContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useMemo } from 'react';\r\nimport { toast } from 'react-toastify';\r\nimport taskService from '../services/taskService';\r\nimport useTaskOptimizations from '../hooks/useTaskOptimizations';\r\nimport { useAuth } from './AuthContext';\r\n\r\n// Create context\r\nconst TaskContext = createContext(null);\r\n\r\nexport const TaskProvider = ({ children }) => {\r\n    const [tasks, setTasks] = useState([]);\r\n    const [currentTask, setCurrentTask] = useState(null);\r\n    const [loading, setLoading] = useState(false);\r\n    const [error, setError] = useState(null);\r\n\r\n    // Use task optimizations hook\r\n    const { debounce, cacheTasks, getCachedTasks } = useTaskOptimizations();\r\n\r\n    // Get current user from auth context\r\n    const { user } = useAuth();\r\n\r\n    // Fetch all tasks or filter by project or user\r\n    const fetchTasks = useCallback(async (filters = {}) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.getTasks(filters);\r\n            setTasks(data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error('Error fetching tasks:', error);\r\n            setError(error.message || 'Failed to fetch tasks');\r\n            toast.error('Failed to fetch tasks');\r\n            return [];\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, []);\r\n\r\n    // Fetch tasks by project ID with caching\r\n    const fetchTasksByProject = useCallback(async (projectId) => {\r\n        try {\r\n            // First check cache\r\n            const cachedData = getCachedTasks(projectId);\r\n            if (cachedData) {\r\n                setTasks(cachedData);\r\n\r\n                // Refresh in background after returning cached data\r\n                taskService.getTasksByProject(projectId).then(freshData => {\r\n                    setTasks(freshData);\r\n                    cacheTasks(projectId, freshData);\r\n                }).catch(err => console.error('Background refresh failed:', err));\r\n\r\n                return cachedData;\r\n            }\r\n\r\n            // If no cache hit, fetch normally\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.getTasksByProject(projectId);\r\n            setTasks(data);\r\n\r\n            // Store in cache for future use\r\n            cacheTasks(projectId, data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error fetching tasks for project ${projectId}:`, error);\r\n            setError(error.message || 'Failed to fetch project tasks');\r\n            toast.error('Failed to fetch project tasks');\r\n            return [];\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [getCachedTasks, cacheTasks]);\r\n\r\n    // Fetch tasks for current user or specified user\r\n    const fetchUserTasks = useCallback(async (userId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n\r\n            // Use 'me' to get current user's tasks\r\n            const data = await taskService.getTasksByUser(userId || 'me');\r\n            setTasks(data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error fetching user tasks:`, error);\r\n            setError(error.message || 'Failed to fetch user tasks');\r\n            toast.error('Failed to fetch user tasks');\r\n            return [];\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, []);\r\n\r\n    // Fetch a single task by ID\r\n    const fetchTask = useCallback(async (taskId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.getTask(taskId);\r\n            setCurrentTask(data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error fetching task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to fetch task');\r\n            toast.error('Failed to fetch task details');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, []);\r\n\r\n    // Create task with debouncing to prevent duplicate submissions\r\n    const createTask = useCallback((taskData) => {\r\n        return debounce(async () => {\r\n            try {\r\n                setLoading(true);\r\n                setError(null);\r\n                const newTask = await taskService.createTask(taskData);\r\n                setTasks(prevTasks => [...prevTasks, newTask]);\r\n                toast.success('Task created successfully');\r\n                return newTask;\r\n            } catch (error) {\r\n                console.error('Error creating task:', error);\r\n                setError(error.message || 'Failed to create task');\r\n                toast.error('Failed to create task');\r\n                return null;\r\n            } finally {\r\n                setLoading(false);\r\n            }\r\n        }, 'createTask', 500)();\r\n    }, [debounce]);\r\n\r\n    // Update a task\r\n    const updateTask = useCallback(async (taskId, taskData) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.updateTask(taskId, taskData);\r\n\r\n            // Update tasks list\r\n            setTasks(prevTasks =>\r\n                prevTasks.map(task =>\r\n                    task._id === taskId ? data : task\r\n                )\r\n            );\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('Task updated successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error updating task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to update task');\r\n            toast.error('Failed to update task');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Delete a task\r\n    const deleteTask = useCallback(async (taskId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            await taskService.deleteTask(taskId);\r\n\r\n            // Remove from tasks list\r\n            setTasks(prevTasks =>\r\n                prevTasks.filter(task => task._id !== taskId)\r\n            );\r\n\r\n            // Clear current task if it's the one being deleted\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(null);\r\n            }\r\n\r\n            toast.success('Task deleted successfully!');\r\n            return true;\r\n        } catch (error) {\r\n            console.error(`Error deleting task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to delete task');\r\n            toast.error('Failed to delete task');\r\n            return false;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Add a comment to a task\r\n    const addComment = useCallback(async (taskId, comment) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.addComment(taskId, comment);\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('Comment added successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error adding comment to task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to add comment');\r\n            toast.error('Failed to add comment');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Upload attachment to a task\r\n    const uploadAttachment = useCallback(async (taskId, file) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.uploadAttachment(taskId, file);\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('File uploaded successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error uploading file to task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to upload file');\r\n            toast.error('Failed to upload file');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Delete attachment from a task\r\n    const deleteAttachment = useCallback(async (taskId, attachmentId) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const data = await taskService.deleteAttachment(taskId, attachmentId);\r\n\r\n            // Update current task if it's the one being modified\r\n            if (currentTask && currentTask._id === taskId) {\r\n                setCurrentTask(data);\r\n            }\r\n\r\n            toast.success('Attachment deleted successfully!');\r\n            return data;\r\n        } catch (error) {\r\n            console.error(`Error deleting attachment from task ${taskId}:`, error);\r\n            setError(error.response?.data?.message || 'Failed to delete attachment');\r\n            toast.error('Failed to delete attachment');\r\n            return null;\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [currentTask]);\r\n\r\n    // Memoize context value\r\n    const contextValue = useMemo(() => ({\r\n        tasks,\r\n        currentTask,\r\n        loading,\r\n        error,\r\n        fetchTasks,\r\n        fetchTasksByProject,\r\n        fetchUserTasks,\r\n        fetchTask,\r\n        createTask,\r\n        updateTask,\r\n        deleteTask,\r\n        addComment,\r\n        uploadAttachment,\r\n        deleteAttachment\r\n    }), [\r\n        tasks,\r\n        currentTask,\r\n        loading,\r\n        error,\r\n        fetchTasks,\r\n        fetchTasksByProject,\r\n        fetchUserTasks,\r\n        fetchTask,\r\n        createTask,\r\n        updateTask,\r\n        deleteTask,\r\n        addComment,\r\n        uploadAttachment,\r\n        deleteAttachment\r\n    ]);\r\n\r\n    return (\r\n        <TaskContext.Provider value={contextValue}>\r\n            {children}\r\n        </TaskContext.Provider>\r\n    );\r\n};\r\n\r\n// Custom hook to use the task context\r\nexport const useTask = () => {\r\n    const context = useContext(TaskContext);\r\n    if (!context) {\r\n        throw new Error('useTask must be used within a TaskProvider');\r\n    }\r\n    return context;\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}