{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Admin\\\\Downloads\\\\Task Management System\\\\frontend\\\\src\\\\context\\\\TaskContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useMemo } from 'react';\nimport { toast } from 'react-toastify';\nimport taskService from '../services/taskService';\nimport useTaskOptimizations from '../hooks/useTaskOptimizations';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst TaskContext = /*#__PURE__*/createContext(null);\nexport const TaskProvider = ({\n  children\n}) => {\n  _s();\n  const [tasks, setTasks] = useState([]);\n  const [currentTask, setCurrentTask] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Use task optimizations hook\n  const {\n    debounce,\n    cacheTasks,\n    getCachedTasks\n  } = useTaskOptimizations();\n\n  // Fetch all tasks or filter by project or user\n  const fetchTasks = useCallback(async (filters = {}) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTasks(filters);\n      setTasks(data);\n      return data;\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n      setError(error.message || 'Failed to fetch tasks');\n      toast.error('Failed to fetch tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch tasks by project ID with caching\n  const fetchTasksByProject = useCallback(async projectId => {\n    try {\n      // First check cache\n      const cachedData = getCachedTasks(projectId);\n      if (cachedData) {\n        setTasks(cachedData);\n\n        // Refresh in background after returning cached data\n        taskService.getTasksByProject(projectId).then(freshData => {\n          setTasks(freshData);\n          cacheTasks(projectId, freshData);\n        }).catch(err => console.error('Background refresh failed:', err));\n        return cachedData;\n      }\n\n      // If no cache hit, fetch normally\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTasksByProject(projectId);\n      setTasks(data);\n\n      // Store in cache for future use\n      cacheTasks(projectId, data);\n      return data;\n    } catch (error) {\n      console.error(`Error fetching tasks for project ${projectId}:`, error);\n      setError(error.message || 'Failed to fetch project tasks');\n      toast.error('Failed to fetch project tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, [getCachedTasks, cacheTasks]);\n\n  // Fetch tasks by user ID\n  const fetchTasksByUser = useCallback(async userId => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTasksByUser(userId);\n      setTasks(data);\n      return data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error(`Error fetching tasks for user ${userId}:`, error);\n      setError(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to fetch user tasks');\n      toast.error('Failed to fetch user tasks');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch a single task by ID\n  const fetchTask = useCallback(async taskId => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.getTask(taskId);\n      setCurrentTask(data);\n      return data;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      console.error(`Error fetching task ${taskId}:`, error);\n      setError(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to fetch task');\n      toast.error('Failed to fetch task details');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Create task with debouncing to prevent duplicate submissions\n  const createTask = useCallback(taskData => {\n    return debounce(async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const newTask = await taskService.createTask(taskData);\n        setTasks(prevTasks => [...prevTasks, newTask]);\n        toast.success('Task created successfully');\n        return newTask;\n      } catch (error) {\n        console.error('Error creating task:', error);\n        setError(error.message || 'Failed to create task');\n        toast.error('Failed to create task');\n        return null;\n      } finally {\n        setLoading(false);\n      }\n    }, 'createTask', 500)();\n  }, [debounce]);\n\n  // Update a task\n  const updateTask = useCallback(async (taskId, taskData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.updateTask(taskId, taskData);\n\n      // Update tasks list\n      setTasks(prevTasks => prevTasks.map(task => task._id === taskId ? data : task));\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Task updated successfully!');\n      return data;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      console.error(`Error updating task ${taskId}:`, error);\n      setError(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to update task');\n      toast.error('Failed to update task');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Delete a task\n  const deleteTask = useCallback(async taskId => {\n    try {\n      setLoading(true);\n      setError(null);\n      await taskService.deleteTask(taskId);\n\n      // Remove from tasks list\n      setTasks(prevTasks => prevTasks.filter(task => task._id !== taskId));\n\n      // Clear current task if it's the one being deleted\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(null);\n      }\n      toast.success('Task deleted successfully!');\n      return true;\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      console.error(`Error deleting task ${taskId}:`, error);\n      setError(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'Failed to delete task');\n      toast.error('Failed to delete task');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Add a comment to a task\n  const addComment = useCallback(async (taskId, comment) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.addComment(taskId, comment);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Comment added successfully!');\n      return data;\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      console.error(`Error adding comment to task ${taskId}:`, error);\n      setError(((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || 'Failed to add comment');\n      toast.error('Failed to add comment');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Upload attachment to a task\n  const uploadAttachment = useCallback(async (taskId, file) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.uploadAttachment(taskId, file);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('File uploaded successfully!');\n      return data;\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      console.error(`Error uploading file to task ${taskId}:`, error);\n      setError(((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.message) || 'Failed to upload file');\n      toast.error('Failed to upload file');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Delete attachment from a task\n  const deleteAttachment = useCallback(async (taskId, attachmentId) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await taskService.deleteAttachment(taskId, attachmentId);\n\n      // Update current task if it's the one being modified\n      if (currentTask && currentTask._id === taskId) {\n        setCurrentTask(data);\n      }\n      toast.success('Attachment deleted successfully!');\n      return data;\n    } catch (error) {\n      var _error$response7, _error$response7$data;\n      console.error(`Error deleting attachment from task ${taskId}:`, error);\n      setError(((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : (_error$response7$data = _error$response7.data) === null || _error$response7$data === void 0 ? void 0 : _error$response7$data.message) || 'Failed to delete attachment');\n      toast.error('Failed to delete attachment');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [currentTask]);\n\n  // Memoize context value\n  const contextValue = useMemo(() => ({\n    tasks,\n    currentTask,\n    loading,\n    error,\n    fetchTasks,\n    fetchTasksByProject,\n    fetchTasksByUser,\n    fetchTask,\n    createTask,\n    updateTask,\n    deleteTask,\n    addComment,\n    uploadAttachment,\n    deleteAttachment\n  }), [tasks, currentTask, loading, error, fetchTasks, fetchTasksByProject, fetchTasksByUser, fetchTask, createTask, updateTask, deleteTask, addComment, uploadAttachment, deleteAttachment]);\n  return /*#__PURE__*/_jsxDEV(TaskContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 295,\n    columnNumber: 9\n  }, this);\n};\n\n// Custom hook to use the task context\n_s(TaskProvider, \"3yiQtaeC6gQJy1Ku3m8BQJXF2PE=\", false, function () {\n  return [useTaskOptimizations];\n});\n_c = TaskProvider;\nexport const useTask = () => {\n  _s2();\n  const context = useContext(TaskContext);\n  if (!context) {\n    throw new Error('useTask must be used within a TaskProvider');\n  }\n  return context;\n};\n_s2(useTask, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TaskProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useMemo","toast","taskService","useTaskOptimizations","jsxDEV","_jsxDEV","TaskContext","TaskProvider","children","_s","tasks","setTasks","currentTask","setCurrentTask","loading","setLoading","error","setError","debounce","cacheTasks","getCachedTasks","fetchTasks","filters","data","getTasks","console","message","fetchTasksByProject","projectId","cachedData","getTasksByProject","then","freshData","catch","err","fetchTasksByUser","userId","getTasksByUser","_error$response","_error$response$data","response","fetchTask","taskId","getTask","_error$response2","_error$response2$data","createTask","taskData","newTask","prevTasks","success","updateTask","map","task","_id","_error$response3","_error$response3$data","deleteTask","filter","_error$response4","_error$response4$data","addComment","comment","_error$response5","_error$response5$data","uploadAttachment","file","_error$response6","_error$response6$data","deleteAttachment","attachmentId","_error$response7","_error$response7$data","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTask","_s2","context","Error","$RefreshReg$"],"sources":["C:/Users/Admin/Downloads/Task Management System/frontend/src/context/TaskContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useMemo } from 'react';\nimport { toast } from 'react-toastify';\nimport taskService from '../services/taskService';\nimport useTaskOptimizations from '../hooks/useTaskOptimizations';\n\n// Create context\nconst TaskContext = createContext(null);\n\nexport const TaskProvider = ({ children }) => {\n    const [tasks, setTasks] = useState([]);\n    const [currentTask, setCurrentTask] = useState(null);\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n\n    // Use task optimizations hook\n    const { debounce, cacheTasks, getCachedTasks } = useTaskOptimizations();\n\n    // Fetch all tasks or filter by project or user\n    const fetchTasks = useCallback(async (filters = {}) => {\n        try {\n            setLoading(true);\n            setError(null);\n            const data = await taskService.getTasks(filters);\n            setTasks(data);\n            return data;\n        } catch (error) {\n            console.error('Error fetching tasks:', error);\n            setError(error.message || 'Failed to fetch tasks');\n            toast.error('Failed to fetch tasks');\n            return [];\n        } finally {\n            setLoading(false);\n        }\n    }, []);\n\n    // Fetch tasks by project ID with caching\n    const fetchTasksByProject = useCallback(async (projectId) => {\n        try {\n            // First check cache\n            const cachedData = getCachedTasks(projectId);\n            if (cachedData) {\n                setTasks(cachedData);\n\n                // Refresh in background after returning cached data\n                taskService.getTasksByProject(projectId).then(freshData => {\n                    setTasks(freshData);\n                    cacheTasks(projectId, freshData);\n                }).catch(err => console.error('Background refresh failed:', err));\n\n                return cachedData;\n            }\n\n            // If no cache hit, fetch normally\n            setLoading(true);\n            setError(null);\n            const data = await taskService.getTasksByProject(projectId);\n            setTasks(data);\n\n            // Store in cache for future use\n            cacheTasks(projectId, data);\n            return data;\n        } catch (error) {\n            console.error(`Error fetching tasks for project ${projectId}:`, error);\n            setError(error.message || 'Failed to fetch project tasks');\n            toast.error('Failed to fetch project tasks');\n            return [];\n        } finally {\n            setLoading(false);\n        }\n    }, [getCachedTasks, cacheTasks]);\n\n    // Fetch tasks by user ID\n    const fetchTasksByUser = useCallback(async (userId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            const data = await taskService.getTasksByUser(userId);\n            setTasks(data);\n            return data;\n        } catch (error) {\n            console.error(`Error fetching tasks for user ${userId}:`, error);\n            setError(error.response?.data?.message || 'Failed to fetch user tasks');\n            toast.error('Failed to fetch user tasks');\n            return [];\n        } finally {\n            setLoading(false);\n        }\n    }, []);\n\n    // Fetch a single task by ID\n    const fetchTask = useCallback(async (taskId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            const data = await taskService.getTask(taskId);\n            setCurrentTask(data);\n            return data;\n        } catch (error) {\n            console.error(`Error fetching task ${taskId}:`, error);\n            setError(error.response?.data?.message || 'Failed to fetch task');\n            toast.error('Failed to fetch task details');\n            return null;\n        } finally {\n            setLoading(false);\n        }\n    }, []);\n\n    // Create task with debouncing to prevent duplicate submissions\n    const createTask = useCallback((taskData) => {\n        return debounce(async () => {\n            try {\n                setLoading(true);\n                setError(null);\n                const newTask = await taskService.createTask(taskData);\n                setTasks(prevTasks => [...prevTasks, newTask]);\n                toast.success('Task created successfully');\n                return newTask;\n            } catch (error) {\n                console.error('Error creating task:', error);\n                setError(error.message || 'Failed to create task');\n                toast.error('Failed to create task');\n                return null;\n            } finally {\n                setLoading(false);\n            }\n        }, 'createTask', 500)();\n    }, [debounce]);\n\n    // Update a task\n    const updateTask = useCallback(async (taskId, taskData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            const data = await taskService.updateTask(taskId, taskData);\n\n            // Update tasks list\n            setTasks(prevTasks =>\n                prevTasks.map(task =>\n                    task._id === taskId ? data : task\n                )\n            );\n\n            // Update current task if it's the one being modified\n            if (currentTask && currentTask._id === taskId) {\n                setCurrentTask(data);\n            }\n\n            toast.success('Task updated successfully!');\n            return data;\n        } catch (error) {\n            console.error(`Error updating task ${taskId}:`, error);\n            setError(error.response?.data?.message || 'Failed to update task');\n            toast.error('Failed to update task');\n            return null;\n        } finally {\n            setLoading(false);\n        }\n    }, [currentTask]);\n\n    // Delete a task\n    const deleteTask = useCallback(async (taskId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            await taskService.deleteTask(taskId);\n\n            // Remove from tasks list\n            setTasks(prevTasks =>\n                prevTasks.filter(task => task._id !== taskId)\n            );\n\n            // Clear current task if it's the one being deleted\n            if (currentTask && currentTask._id === taskId) {\n                setCurrentTask(null);\n            }\n\n            toast.success('Task deleted successfully!');\n            return true;\n        } catch (error) {\n            console.error(`Error deleting task ${taskId}:`, error);\n            setError(error.response?.data?.message || 'Failed to delete task');\n            toast.error('Failed to delete task');\n            return false;\n        } finally {\n            setLoading(false);\n        }\n    }, [currentTask]);\n\n    // Add a comment to a task\n    const addComment = useCallback(async (taskId, comment) => {\n        try {\n            setLoading(true);\n            setError(null);\n            const data = await taskService.addComment(taskId, comment);\n\n            // Update current task if it's the one being modified\n            if (currentTask && currentTask._id === taskId) {\n                setCurrentTask(data);\n            }\n\n            toast.success('Comment added successfully!');\n            return data;\n        } catch (error) {\n            console.error(`Error adding comment to task ${taskId}:`, error);\n            setError(error.response?.data?.message || 'Failed to add comment');\n            toast.error('Failed to add comment');\n            return null;\n        } finally {\n            setLoading(false);\n        }\n    }, [currentTask]);\n\n    // Upload attachment to a task\n    const uploadAttachment = useCallback(async (taskId, file) => {\n        try {\n            setLoading(true);\n            setError(null);\n            const data = await taskService.uploadAttachment(taskId, file);\n\n            // Update current task if it's the one being modified\n            if (currentTask && currentTask._id === taskId) {\n                setCurrentTask(data);\n            }\n\n            toast.success('File uploaded successfully!');\n            return data;\n        } catch (error) {\n            console.error(`Error uploading file to task ${taskId}:`, error);\n            setError(error.response?.data?.message || 'Failed to upload file');\n            toast.error('Failed to upload file');\n            return null;\n        } finally {\n            setLoading(false);\n        }\n    }, [currentTask]);\n\n    // Delete attachment from a task\n    const deleteAttachment = useCallback(async (taskId, attachmentId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            const data = await taskService.deleteAttachment(taskId, attachmentId);\n\n            // Update current task if it's the one being modified\n            if (currentTask && currentTask._id === taskId) {\n                setCurrentTask(data);\n            }\n\n            toast.success('Attachment deleted successfully!');\n            return data;\n        } catch (error) {\n            console.error(`Error deleting attachment from task ${taskId}:`, error);\n            setError(error.response?.data?.message || 'Failed to delete attachment');\n            toast.error('Failed to delete attachment');\n            return null;\n        } finally {\n            setLoading(false);\n        }\n    }, [currentTask]);\n\n    // Memoize context value\n    const contextValue = useMemo(() => ({\n        tasks,\n        currentTask,\n        loading,\n        error,\n        fetchTasks,\n        fetchTasksByProject,\n        fetchTasksByUser,\n        fetchTask,\n        createTask,\n        updateTask,\n        deleteTask,\n        addComment,\n        uploadAttachment,\n        deleteAttachment\n    }), [\n        tasks,\n        currentTask,\n        loading,\n        error,\n        fetchTasks,\n        fetchTasksByProject,\n        fetchTasksByUser,\n        fetchTask,\n        createTask,\n        updateTask,\n        deleteTask,\n        addComment,\n        uploadAttachment,\n        deleteAttachment\n    ]);\n\n    return (\n        <TaskContext.Provider value={contextValue}>\n            {children}\n        </TaskContext.Provider>\n    );\n};\n\n// Custom hook to use the task context\nexport const useTask = () => {\n    const context = useContext(TaskContext);\n    if (!context) {\n        throw new Error('useTask must be used within a TaskProvider');\n    }\n    return context;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}